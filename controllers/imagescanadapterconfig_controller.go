/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"
	"fmt"

	"strings"
	"time"

	libk8s "github.com/ckotzbauer/libk8soci/pkg/kubernetes"
	"github.com/ckotzbauer/libk8soci/pkg/oci"
	"github.com/go-logr/logr"
	"github.com/novln/docker-parser"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	policyreport "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/api/wgpolicyk8s.io/v1alpha2"
	wgclient "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/generated/v1alpha2/clientset/versioned"

	vulnv1alpha1 "github.com/kbeniwal/vulnerability-adapter/api/v1alpha1"
	"github.com/kbeniwal/vulnerability-adapter/controllers/helper"
	"github.com/kbeniwal/vulnerability-adapter/controllers/scanner"
	"github.com/kbeniwal/vulnerability-adapter/controllers/scanner/grype"
)

const (
	ScanInProgress vulnv1alpha1.StatusResult = "inProgress"
	ScanFailure    vulnv1alpha1.StatusResult = "failure"
	ScanSuccess    vulnv1alpha1.StatusResult = "success"
)

// ImageScanAdapterConfigReconciler reconciles a ImageScanAdapterConfig object
type ImageScanAdapterConfigReconciler struct {
	client.Client
	Scheme                      *runtime.Scheme
	updatedStatusOnceAfterStart bool
}

//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs/finalizers,verbs=update
//+kubebuilder:rbac:groups="",resources=namespaces,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch
//+kubebuilder:rbac:groups=wgpolicyk8s.io,resources=policyreports,verbs=get;list;watch;create;update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the ImageScanAdapterConfig object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.13.0/pkg/reconcile
func (r *ImageScanAdapterConfigReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	currentRunStartTimestamp := time.Now()
	l := log.FromContext(ctx)

	objOld := &vulnv1alpha1.ImageScanAdapterConfig{}
	err := r.Get(ctx, req.NamespacedName, objOld)
	if err != nil {
		if client.IgnoreNotFound(err) == nil {
			l.Info("Warning: Resource deleted or does not exist")
		}
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	if !objOld.DeletionTimestamp.IsZero() {
		l.Info("Warning: Deleting resource. Hope this is done intentionally.")
		return ctrl.Result{}, nil
	}

	scanInterval, err := time.ParseDuration(objOld.Spec.ScanInterval)
	if err != nil {
		l.Info("Warning: Could not parse Scan Interval", "error", err.Error())
		return ctrl.Result{}, nil
	}

	if !isStatusEmpty(&objOld.Status) {
		nextRunTime := objOld.Status.LastRunEndTime.Add(scanInterval)
		if r.updatedStatusOnceAfterStart && metav1.Now().Time.Before(nextRunTime) {
			return ctrl.Result{}, nil
		}
	}

	r.updateCurrentRunStatusInProgress(ctx, objOld, &l)

	l.Info("Reconciling", "req", req)

	// Load Scan Items.
	namespaces, err := loadNamespaces(objOld.Spec.Selectors.Namespaces)
	if err != nil {
		l.Error(err, "error loading namespaces")
		return r.updateLastRunStatusFailure(ctx, objOld, "error loading namespaces", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
	}
	var scanItems []helper.Image
	if objOld.Spec.ScanAll {
		l.Info("Loading scan items")
		scanItems, err = loadScanItems(namespaces)
		if err != nil {
			l.Error(err, "error occurred while loading scan items")
			return r.updateLastRunStatusFailure(ctx, objOld, "error occurred while loading scan items", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
		}
		l.Info("Scan items loaded successfully")
	} else {
		l.Info("Loading stale/invalid scan items")
		failedItems, err := r.loadFailedItems(ctx, namespaces)
		if err != nil {
			l.Error(err, "error occurred while loading stale/invalid scan items")
			return r.updateLastRunStatusFailure(ctx, objOld, "error occurred while loading stale/invalid scan items", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
		}
		l.Info("Stale/invalid scan items loaded successfully")
		scanItems = append(scanItems, failedItems...)

		l.Info("Loading unverified scan items")
		verifiedItems, err := loadUnverifiedItems(ctx, namespaces)
		if err != nil {
			l.Error(err, "error occurred while loading unverified scan items")
			return r.updateLastRunStatusFailure(ctx, objOld, "error occurred while loading unverified scan items", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
		}
		l.Info("Unverified scan items loaded successfully")
		scanItems = append(scanItems, verifiedItems...)
	}

	numScanItems := len(scanItems)
	l.Info("Number of Scan Items", "numScanItems", numScanItems)

	// Init Scanner.
	var scanner scanner.Scanner
	if objOld.Spec.ScannerEngine == "grype" {
		severity := objOld.Spec.Severity
		if len(severity) == 0 {
			severity = []string{"medium", "high", "critical"}
		}
		scanner, err = grype.New("", "", severity, false)
		if err != nil {
			return r.updateLastRunStatusFailure(ctx, objOld, "error occurred while initializing scanner", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
		}
	} else {
		l.Info(fmt.Sprintf("Unknown scanner engine '%s'", objOld.Spec.ScannerEngine))
		return r.updateLastRunStatusFailure(ctx, objOld, fmt.Sprintf("Unknown scanner engine '%s'", objOld.Spec.ScannerEngine), err, &l, scanInterval, currentRunStartTimestamp, time.Now())
	}

	defer scanner.Close()

	// Scan Items.
	scanStartTime := time.Now()
	scanResult := helper.ScanResult{FoundVulnerabilities: []helper.Vulnerability{}, AuditedVulnerabilities: []helper.Vulnerability{}}
	for _, scanItem := range scanItems {
		l.Info(fmt.Sprintf("Scan Image %s", scanItem.Image))
		result, err := scanner.ScanItem(scanItem)

		if err == nil {
			l.Info(fmt.Sprintf("Image %s scanned successfully", scanItem.Image))
			// handle result
			scanResult = helper.ScanResult{
				FoundVulnerabilities:   append(scanResult.FoundVulnerabilities, result.FoundVulnerabilities...),
				AuditedVulnerabilities: append(scanResult.AuditedVulnerabilities, result.AuditedVulnerabilities...),
			}
		} else {
			l.Error(err, fmt.Sprintf("error scanning image %s", scanItem.Image))
		}
	}
	scanEndTime := time.Now()

	l.Info("Time spent scanning", "scanTime", (scanEndTime.Sub(scanStartTime)).Seconds())

	// Process Vulnerabilities.
	l.Info("Process vulnerabilities.")
	foundVulns := make(map[string][]podVulnerability)
	auditedVulns := make(map[string][]podVulnerability)
	err = ProcessVulns(scanResult, foundVulns, auditedVulns)
	if err != nil {
		log.Log.Error(err, "Target could not process vulnerabilities")
	} else {
		l.Info("Vulnerabilities processed successfully.")
	}

	// Create/Update PolicyReport.
	err = Finalize(foundVulns, auditedVulns, objOld.Spec.PolicyReportPrefix, objOld.ObjectMeta.Name)
	if err != nil {
		l.Error(err, "Target could not be finalized")
		return r.updateLastRunStatusFailure(ctx, objOld, "error occurred while creating/updating target", err, &l, scanInterval, currentRunStartTimestamp, time.Now())
	}

	return r.updateLastRunStatusSuccess(ctx, objOld, &l, scanInterval, currentRunStartTimestamp, time.Now())
}

func loadNamespaces(namespaces []string) ([]string, error) {
	if len(namespaces) > 0 && namespaces[0] != "*" {
		return namespaces, nil
	}

	client := libk8s.NewClient()
	loadedNamespaces, err := client.Client.CoreV1().Namespaces().List(context.Background(), metav1.ListOptions{})
	if err != nil {
		return []string{}, err
	}
	namespaces = make([]string, 0)
	for _, namespace := range loadedNamespaces.Items {
		namespaces = append(namespaces, namespace.Name)
	}
	return namespaces, nil
}

func loadScanItems(namespaces []string) ([]helper.Image, error) {
	client := libk8s.NewClient()

	scanItems := make([]helper.Image, 0)
	for _, namespace := range namespaces {
		pods, err := client.Client.CoreV1().Pods(namespace).List(context.Background(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}

		images := make(map[string]bool, 0)

		for _, p := range pods.Items {
			for _, cs := range p.Status.ContainerStatuses {
				image := helper.Image{
					RegistryImage: oci.RegistryImage{
						ImageID: cs.ImageID,
						Image:   cs.Image,
					},
				}
				if _, ok := images[cs.Image]; !ok {
					images[cs.Image] = true
					scanItems = append(scanItems, image)
				}
			}
		}
	}
	return scanItems, nil
}

func loadUnverifiedItems(ctx context.Context, namespaces []string) ([]helper.Image, error) {
	cfg, err := DefaultConfig()
	if err != nil {
		log.Log.Error(err, "RestConfig detection failed")
		return []helper.Image{}, err
	}

	ctl, err := wgclient.NewForConfig(cfg)
	if err != nil {
		log.Log.Error(err, "Client creation failed")
		return []helper.Image{}, err
	}

	listedPods := make(map[string]string, 0)
	for _, ns := range namespaces {
		namespacedReport := ctl.Wgpolicyk8sV1alpha2().PolicyReports(ns)
		polrs, err := namespacedReport.List(ctx, metav1.ListOptions{})
		if err != nil {
			return []helper.Image{}, err
		}
		for _, polr := range polrs.Items {
			for _, result := range polr.Results {
				listedPods[result.Subjects[0].Name] = ns
			}
		}
	}

	client := libk8s.NewClient()

	scanItems := make([]helper.Image, 0)
	for _, namespace := range namespaces {
		pods, err := client.Client.CoreV1().Pods(namespace).List(context.Background(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}

		images := make(map[string]bool, 0)

		for _, p := range pods.Items {
			if p.Name == "kube-proxy-zs5cj" {
				// do nothing, let it continue.
			} else if listedPods[p.Name] == namespace {
				continue
			}

			for _, cs := range p.Status.ContainerStatuses {
				image := helper.Image{
					RegistryImage: oci.RegistryImage{
						ImageID: cs.ImageID,
						Image:   cs.Image,
					},
				}
				if _, ok := images[cs.Image]; !ok {
					images[cs.Image] = true
					scanItems = append(scanItems, image)
				}
			}
		}
	}

	return scanItems, nil
}

func (r *ImageScanAdapterConfigReconciler) loadFailedItems(ctx context.Context, namespaces []string) ([]helper.Image, error) {
	cfg, err := DefaultConfig()
	if err != nil {
		log.Log.Error(err, "RestConfig detection failed")
		return []helper.Image{}, err
	}

	ctl, err := wgclient.NewForConfig(cfg)
	if err != nil {
		log.Log.Error(err, "Client creation failed")
		return []helper.Image{}, err
	}

	scanItems := make([]helper.Image, 0)
	for _, ns := range namespaces {
		namespacedReport := ctl.Wgpolicyk8sV1alpha2().PolicyReports(ns)
		polr, err := namespacedReport.Get(context.Background(), "cpol-check-pod-name", metav1.GetOptions{})
		if err != nil {
			if errors.IsNotFound(err) {
				log.Log.Info(fmt.Sprintf("Policy Report 'cpol-check-pod-name' not found in namespace %s", ns))
			} else {
				return []helper.Image{}, err
			}
		}

		client := libk8s.NewClient()
		images := make(map[string]bool, 0)
		for _, result := range polr.Results {
			if result.Result == "fail" && result.Subjects[0].Kind == "Pod" {
				// get image for the pod
				podName := result.Subjects[0].Name
				pod, err := client.Client.CoreV1().Pods(ns).Get(ctx, podName, metav1.GetOptions{})
				if err != nil {
					log.Log.Error(err, fmt.Sprintf("error getting pod: %s", podName))
				}
				for _, cs := range pod.Status.ContainerStatuses {
					image := helper.Image{
						RegistryImage: oci.RegistryImage{
							ImageID: cs.ImageID,
							Image:   cs.Image,
						},
					}
					if _, ok := images[cs.Image]; !ok {
						images[cs.Image] = true
						scanItems = append(scanItems, image)
					}
				}
			}
		}
	}

	return scanItems, nil
}

func Finalize(foundVulns, auditedVulns map[string][]podVulnerability, polrPrefix, configRef string) error {
	cfg, err := DefaultConfig()
	if err != nil {
		log.Log.Error(err, "RestConfig detection failed")
		return err
	}

	ctl, err := wgclient.NewForConfig(cfg)
	if err != nil {
		log.Log.Error(err, "Client creation failed")
		return err
	}

	for _, podVulns := range foundVulns {
		finalizePodVulns(podVulns, ctl, false, polrPrefix, configRef)
	}

	for _, podVulns := range auditedVulns {
		finalizePodVulns(podVulns, ctl, true, polrPrefix, configRef)
	}

	return nil
}

func finalizePodVulns(podVulns []podVulnerability, ctl *wgclient.Clientset, audited bool, polrPrefix, configRef string) {
	v := podVulns[0]

	namespacedReport := ctl.Wgpolicyk8sV1alpha2().PolicyReports(v.container.Namespace)
	report := generatePolicyReport(v.container, podVulns, audited, polrPrefix, configRef)

	_, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		log.Log.Info(fmt.Sprintf("Create PolicyReport %s/%s", v.container.Namespace, report.Name))
		_, err = namespacedReport.Create(context.Background(), report, metav1.CreateOptions{})
		if err != nil {
			log.Log.Error(err, "PolicyReport could not be created")
		}
	} else if err != nil {
		log.Log.Error(err, "PolicyReport could not be fetched")
	} else {
		retryErr := retry.RetryOnConflict(retry.DefaultRetry, func() error {
			getObj, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
			if errors.IsNotFound(err) {
				// This doesnt ever happen even if it is already deleted or not found
				log.Log.Info(fmt.Sprintf("PolicyReport %s not found for update", report.Name))
				return nil
			}

			if err != nil {
				return err
			}

			log.Log.Info(fmt.Sprintf("Update PolicyReport %s/%s", v.container.Namespace, report.Name))
			report.SetResourceVersion(getObj.GetResourceVersion())
			_, updateErr := namespacedReport.Update(context.Background(), report, metav1.UpdateOptions{})
			return updateErr
		})

		if retryErr != nil {
			log.Log.Error(err, "PolicyReport could not be updated")
		}
	}
}

func generatePolicyReport(container helper.ContainerInfo, vulnerabilities []podVulnerability, audited bool, polrPrefix, configRef string) *policyreport.PolicyReport {
	suffix := ""
	if audited {
		suffix = "-audited"
	}

	report := policyreport.PolicyReport{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s-%s%s", polrPrefix, container.PodName, suffix),
			Namespace: container.Namespace,
			Labels: map[string]string{
				"kubernetes.io/createdBy": "vulnerability-operator",
			},
			OwnerReferences: []metav1.OwnerReference{
				{APIVersion: "v1", Kind: "Pod", Name: container.PodName, UID: container.PodUID},
			},
		},
		Scope:   &corev1.ObjectReference{Kind: "Pod", Namespace: container.Namespace, Name: container.PodName, UID: container.PodUID},
		Results: []*policyreport.PolicyReportResult{},
	}

	t := time.Now()
	tUnix := t.Unix()
	tUnixNano := int32(t.UnixNano())

	imageId, repo, registry, tag, err := parseImage(vulnerabilities[0].vulnerability.Image)
	if err != nil {
		log.Log.Error(err, "error parsing docker image")
		return nil
	}
	for _, v := range vulnerabilities {
		result := policyreport.PolicyReportResult{
			Timestamp:   metav1.Timestamp{Nanos: tUnixNano, Seconds: tUnix},
			Policy:      v.vulnerability.ID,
			Description: v.vulnerability.Description,
			Source:      "image-vulnerability-scan-adapter",
			Category:    "Vulnerability Scan",
			Scored:      false,
			Subjects: []*corev1.ObjectReference{
				{
					Kind:      "Pod",
					Namespace: container.Namespace,
					Name:      container.PodName,
					UID:       container.PodUID,
				},
			},
			Severity: mapSeverity(v.vulnerability.Severity),
			Properties: map[string]string{
				"image":            v.vulnerability.Image.Image,
				"imageDigest":      imageId,
				"imageRepo":        repo,
				"imageRegistry":    registry,
				"imageTag":         tag,
				"configRef":        configRef,
				"package":          v.vulnerability.Package,
				"installedVersion": v.vulnerability.Installed,
				"fixedVersion":     firstOrEmpty(v.vulnerability.FixedIn),
				"url":              firstOrEmpty(v.vulnerability.URLs),
			},
			Result: mapResult(v.vulnerability.Severity),
		}

		report.Results = append(report.Results, &result)
	}

	report.Summary = toSummaryPolicy(report.Results)
	return &report
}

func parseImage(item helper.Image) (string, string, string, string, error) {
	parts := strings.Split(item.ImageId(), "//")
	imageId := parts[1]

	ref, err := dockerparser.Parse(item.Image)
	if err != nil {
		return "", "", "", "", err
	}
	repo := ref.Repository()
	registry := ref.Registry()
	tag := ref.Tag()
	repo = strings.TrimPrefix(repo, registry+"/")
	return imageId, repo, registry, tag, nil
}

func mapSeverity(s string) policyreport.PolicyResultSeverity {
	if s == "Low" {
		return "low"
	} else if s == "Medium" {
		return "medium"
	} else if s == "High" || s == "Critical" {
		return "high"
	}

	return ""
}

func mapResult(s string) policyreport.PolicyResult {
	if s == "Low" {
		return "warn"
	} else if s == "Medium" || s == "High" || s == "Critical" {
		return "fail"
	}

	return "pass"
}

func toSummaryPolicy(results []*policyreport.PolicyReportResult) policyreport.PolicyReportSummary {
	var rs policyreport.PolicyReportSummary
	for _, v := range results {
		switch v.Result {
		case "error":
			rs.Error++
		case "fail":
			rs.Fail++
		case "warn":
			rs.Warn++
		case "pass":
			rs.Pass++
		default:
			rs.Skip++
		}
	}
	return rs
}

func firstOrEmpty(slice []string) string {
	if len(slice) > 0 {
		return slice[0]
	}

	return ""
}

func DefaultConfig() (*rest.Config, error) {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()

	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	return config, nil
}

func ProcessVulns(result helper.ScanResult, foundVulns, auditedVulns map[string][]podVulnerability) error {
	for _, v := range result.FoundVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := foundVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			foundVulns[id] = podVulns
		}
	}

	for _, v := range result.AuditedVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := auditedVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			auditedVulns[id] = podVulns
		}
	}

	return nil
}

type podVulnerability struct {
	container     helper.ContainerInfo
	vulnerability helper.Vulnerability
}

// SetupWithManager sets up the controller with the Manager.
func (r *ImageScanAdapterConfigReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&vulnv1alpha1.ImageScanAdapterConfig{}).
		Complete(r)
}

func (r *ImageScanAdapterConfigReconciler) updateCurrentRunStatusInProgress(ctx context.Context, objOld *vulnv1alpha1.ImageScanAdapterConfig, l *logr.Logger) {
	objOld.Status = vulnv1alpha1.ImageScanAdapterConfigStatus{
		Result:  ScanInProgress,
		Message: "reconciling",
	}
	if err := r.Status().Update(ctx, objOld); err != nil {
		l.Error(err, "error updating current run's status in progress")
	} else {
		r.updatedStatusOnceAfterStart = true
	}
}

func (r *ImageScanAdapterConfigReconciler) updateLastRunStatusFailure(ctx context.Context, objOld *vulnv1alpha1.ImageScanAdapterConfig, msg string, err error, l *logr.Logger, scanInterval time.Duration, currentRunStartTimestamp, currentRunEndTimestamp time.Time) (ctrl.Result, error) {
	objOld.Status = vulnv1alpha1.ImageScanAdapterConfigStatus{
		Result:           ScanFailure,
		Message:          msg,
		LastRunStartTime: &metav1.Time{Time: currentRunStartTimestamp},
		LastRunEndTime:   &metav1.Time{Time: currentRunEndTimestamp},
	}

	if err := r.Status().Update(ctx, objOld); err != nil {
		l.Error(err, "error updating last run's status failure")
	} else {
		r.updatedStatusOnceAfterStart = true
	}

	return ctrl.Result{RequeueAfter: scanInterval}, nil
}

func (r *ImageScanAdapterConfigReconciler) updateLastRunStatusSuccess(ctx context.Context, objOld *vulnv1alpha1.ImageScanAdapterConfig, l *logr.Logger, scanInterval time.Duration, currentRunStartTimestamp, currentRunEndTimestamp time.Time) (ctrl.Result, error) {
	objOld.Status = vulnv1alpha1.ImageScanAdapterConfigStatus{
		Result:           ScanSuccess,
		Message:          fmt.Sprintf("reconcilation completed successfully, next run at %s", currentRunEndTimestamp.Add(scanInterval)),
		LastRunStartTime: &metav1.Time{Time: currentRunStartTimestamp},
		LastRunEndTime:   &metav1.Time{Time: currentRunEndTimestamp},
	}

	if err := r.Status().Update(ctx, objOld); err != nil {
		l.Error(err, "error updating last run's status success")
	} else {
		r.updatedStatusOnceAfterStart = true
	}

	return ctrl.Result{RequeueAfter: scanInterval}, nil
}

func isStatusEmpty(status *vulnv1alpha1.ImageScanAdapterConfigStatus) bool {
	return (status.LastRunStartTime == nil &&
		status.LastRunEndTime == nil)
}
