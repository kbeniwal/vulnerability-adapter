package helper

import (
	"context"
	"strings"

	libk8s "github.com/ckotzbauer/libk8soci/pkg/kubernetes"
	"github.com/ckotzbauer/libk8soci/pkg/oci"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	metaTypes "k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

type KubeClient struct {
	Client *libk8s.KubeClient
	pods   []corev1.Pod
	owners map[string]owner
}

type owner struct {
	kind string
	name string
}

func (client *KubeClient) getOwner(pod corev1.Pod) owner {
	ownerKind, ownerName := getOwnerKindAndName(pod.OwnerReferences)
	ctx := context.Background()

	if ownerKind == "ReplicaSet" {
		rs, _ := client.Client.Client.AppsV1().ReplicaSets(pod.Namespace).Get(ctx, ownerName, metav1.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(rs.OwnerReferences)
		return owner{kind: ownerKind, name: ownerName}
	} else if ownerKind == "Job" {
		job, _ := client.Client.Client.BatchV1().Jobs(pod.Namespace).Get(ctx, ownerName, metav1.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(job.OwnerReferences)
		if ownerKind == "" && ownerName == "" {
			return owner{kind: "Job", name: job.Name}
		} else {
			return owner{kind: ownerKind, name: ownerName}
		}
	} else if ownerKind != "" {
		// A StatefulSet, DaemonSet or CRD-Operator created the pod
		return owner{kind: ownerKind, name: ownerName}
	} else {
		// Single pod without owner
		return owner{kind: "Pod", name: pod.Name}
	}
}

func getOwnerKindAndName(refs []metav1.OwnerReference) (string, string) {
	if len(refs) > 0 {
		return refs[0].Kind, refs[0].Name
	}

	return "", ""
}

func (client *KubeClient) GetContainersWithImage(imageID string) ([]ContainerInfo, error) {
	if client.pods == nil {
		err := client.loadPods()

		if err != nil {
			return nil, err
		}
	}

	infos := make([]ContainerInfo, 0)

	for _, p := range client.pods {
		ref := p.Namespace + "/" + p.Name
		owner, ok := client.owners[ref]
		if !ok {
			owner = client.getOwner(p)
		}
		client.owners[ref] = owner

		statuses := p.Status.ContainerStatuses
		statuses = append(statuses, p.Status.InitContainerStatuses...)
		statuses = append(statuses, p.Status.EphemeralContainerStatuses...)

		for _, c := range statuses {
			fixedImageID := strings.ReplaceAll(c.ImageID, "docker-pullable://", "")
			if fixedImageID == imageID {
				infos = append(infos, ContainerInfo{
					Namespace:     p.Namespace,
					PodName:       p.Name,
					PodUID:        p.UID,
					OwnerName:     owner.name,
					OwnerKind:     owner.kind,
					ContainerName: c.Name,
				})
			}
		}
	}

	return infos, nil
}

func (client *KubeClient) loadPods() error {
	list, err := client.Client.Client.CoreV1().Pods("").List(context.Background(), metav1.ListOptions{})

	if err != nil {
		log.Log.Error(err, "ListPods errored!")
		return err
	}

	client.pods = list.Items
	return nil
}

func NewClient() *KubeClient {
	return &KubeClient{Client: libk8s.NewClient(), owners: make(map[string]owner)}
}

type FilterEngine struct {
	config *FilterConfig
}

func NewFilterEngine(config *FilterConfig) *FilterEngine {
	return &FilterEngine{config: config}
}

type FilterConfig struct {
	Ignore []VulnerabilityFilter `yaml:"ignore"`
	Audit  []VulnerabilityFilter `yaml:"audit"`
}

func (f *FilterEngine) FilterVulnerabilities(vulns []Vulnerability) ([]Vulnerability, []Vulnerability) {
	audited := make([]Vulnerability, 0)
	found := make([]Vulnerability, 0)

	for _, vuln := range vulns {
		_, notFiltered := matchesAnyFilter(vuln, f.config.Ignore)
		filtered, notFiltered := matchesAnyFilter(notFiltered, f.config.Audit)
		if len(filtered.Containers) > 0 {
			audited = append(audited, filtered)
		}

		if len(notFiltered.Containers) > 0 {
			found = append(found, notFiltered)
		}
	}

	return found, audited
}

func matchesAnyFilter(v Vulnerability, filters []VulnerabilityFilter) (Vulnerability, Vulnerability) {
	for _, filter := range filters {
		match, filtered, notFiltered := matches(v, filter)
		if match {
			return filtered, notFiltered
		}
	}

	return Vulnerability{}, v
}

func matches(v Vulnerability, filter VulnerabilityFilter) (bool, Vulnerability, Vulnerability) {
	appliedContainers := make([]ContainerInfo, 0)
	notAppliedContainers := make([]ContainerInfo, 0)

	if len(filter.Context) > 0 {
		for _, ctx := range filter.Context {
			for _, container := range v.Containers {
				name := container.OwnerName
				if container.OwnerKind == "Pod" {
					name = container.PodName
				}

				if matchesContainer(v.Image.ImageId(), ctx.Image) &&
					matchesContainer(container.OwnerKind, ctx.Kind) &&
					matchesContainer(name, ctx.Name) &&
					matchesContainer(container.Namespace, ctx.Namespace) {
					appliedContainers = append(appliedContainers, container)
				} else {
					notAppliedContainers = append(notAppliedContainers, container)
				}
			}
		}
	} else {
		appliedContainers = v.Containers
	}

	if len(appliedContainers) == 0 {
		return false, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	if v.ID == filter.Vulnerability {
		return true, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	if v.Package == filter.Package {
		return true, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	return false, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
}

func fromVulnerability(v Vulnerability, containers []ContainerInfo) Vulnerability {
	return Vulnerability{
		ID:          v.ID,
		Namespace:   v.Namespace,
		Severity:    v.Severity,
		Type:        v.Type,
		Package:     v.Package,
		Description: v.Description,
		Installed:   v.Installed,
		FixedIn:     v.FixedIn,
		FixState:    v.FixState,
		URLs:        v.URLs,
		Image:       v.Image,
		Containers:  containers,
	}
}

func matchesContainer(value, pattern string) bool {
	if pattern == "" {
		return true
	}

	return IsMatch(value, pattern)
}

func IsMatch(s string, p string) bool {
	runeInput := []rune(s)
	runePattern := []rune(p)

	lenInput := len(runeInput)
	lenPattern := len(runePattern)

	isMatchingMatrix := make([][]bool, lenInput+1)

	for i := range isMatchingMatrix {
		isMatchingMatrix[i] = make([]bool, lenPattern+1)
	}

	isMatchingMatrix[0][0] = true
	for i := 1; i < lenInput; i++ {
		isMatchingMatrix[i][0] = false
	}

	if lenPattern > 0 {
		if runePattern[0] == '*' {
			isMatchingMatrix[0][1] = true
		}
	}

	for j := 2; j <= lenPattern; j++ {
		if runePattern[j-1] == '*' {
			isMatchingMatrix[0][j] = isMatchingMatrix[0][j-1]
		}

	}

	for i := 1; i <= lenInput; i++ {
		for j := 1; j <= lenPattern; j++ {

			if runePattern[j-1] == '*' {
				isMatchingMatrix[i][j] = isMatchingMatrix[i-1][j] || isMatchingMatrix[i][j-1]
			}

			if runePattern[j-1] == '?' || runeInput[i-1] == runePattern[j-1] {
				isMatchingMatrix[i][j] = isMatchingMatrix[i-1][j-1]
			}
		}
	}

	return isMatchingMatrix[lenInput][lenPattern]
}

type VulnerabilityFilter struct {
	Vulnerability string          `yaml:"vulnerability"`
	Package       string          `yaml:"package"`
	Context       []FilterContext `yaml:"context"`
}

type FilterContext struct {
	Image     string `yaml:"image"`
	Namespace string `yaml:"namespace"`
	Name      string `yaml:"name"`
	Kind      string `yaml:"kind"`
}

type Image struct {
	oci.RegistryImage
}

func (s Image) ImageId() string {
	return s.ImageID
}

func (s Image) ScanInput() string {
	return "registry:" + s.Image
}

func (s Image) Cleanup() error {
	return nil
}

type ContainerInfo struct {
	Namespace     string
	OwnerName     string
	OwnerKind     string
	PodName       string
	PodUID        metaTypes.UID
	ContainerName string
}

func NewContainerInfos() []ContainerInfo {
	return []ContainerInfo{}
}

type Vulnerability struct {
	ID          string
	Namespace   string
	Severity    string
	Type        string
	Description string
	Package     string
	Installed   string
	FixedIn     []string
	FixState    string
	URLs        []string
	Image       Image
	Containers  []ContainerInfo
}

type ScanResult struct {
	FoundVulnerabilities   []Vulnerability
	AuditedVulnerabilities []Vulnerability
}
