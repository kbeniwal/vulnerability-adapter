package grype

import (
	"fmt"
	"os"

	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	v5 "github.com/anchore/grype/grype/db/v5"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/matcher"
	"github.com/anchore/grype/grype/pkg"
	grype_models "github.com/anchore/grype/grype/presenter/models"
	"github.com/anchore/grype/grype/store"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/stereoscope/pkg/image"
	"github.com/anchore/syft/syft/pkg/cataloger"
	"github.com/ckotzbauer/libk8soci/pkg/oci"
	"gopkg.in/yaml.v3"
	"sigs.k8s.io/controller-runtime/pkg/log"

	"github.com/kbeniwal/vulnerability-adapter/controllers/helper"
	"github.com/kbeniwal/vulnerability-adapter/controllers/scanner"
)

type Grype struct {
	store          *store.Store
	dbCloser       *db.Closer
	dbStatus       *db.Status
	kubeClient     *helper.KubeClient
	config         grypeConfig
	relatedEntries map[string]string
	onlyFixed      bool
	severity       []string
	filterEngine   *helper.FilterEngine
}

type grypeConfig struct {
	Ignore []match.IgnoreRule `yaml:"ignore"`
}

func New(grypeConfigFile, filterConfigFile string, severity []string, onlyFixed bool) (scanner.Scanner, error) {
	grypeCfg, err := loadConfig(grypeConfigFile, grypeConfig{})
	if err != nil {
		return nil, err
	}

	config := db.Config{
		ListingURL:          "https://toolbox-data.anchore.io/grype/databases/listing.json",
		DBRootDir:           "/tmp/grype/db",
		ValidateByHashOnGet: false,
	}

	log.Log.Info("Load vulnerability database")
	store, dbStatus, dbCloser, err := grype.LoadVulnerabilityDB(config, true)
	if err = validateDBLoad(err, dbStatus); err != nil {
		log.Log.Error(err, "load db error")
		return nil, err
	}
	log.Log.Info("Vulnerability database loaded successfully")

	filterConfig, err := loadConfig(filterConfigFile, helper.FilterConfig{})
	if err != nil {
		return nil, err
	}

	client := helper.NewClient()

	return &Grype{
		store:          store,
		dbCloser:       dbCloser,
		dbStatus:       dbStatus,
		kubeClient:     client,
		config:         *grypeCfg,
		severity:       severity,
		onlyFixed:      onlyFixed,
		relatedEntries: map[string]string{},
		filterEngine:   helper.NewFilterEngine(filterConfig),
	}, nil
}

func (s *Grype) ScanItem(item helper.Image) (helper.ScanResult, error) {
	registryOptions := &image.RegistryOptions{}
	registryOptions.Credentials = oci.ConvertSecrets(item.RegistryImage, map[string]string{})

	packages, context, _, err := pkg.Provide(item.ScanInput(), pkg.ProviderConfig{
		SyftProviderConfig: pkg.SyftProviderConfig{
			CatalogingOptions: cataloger.DefaultConfig(),
			RegistryOptions:   registryOptions,
		},
	})
	if err != nil {
		log.Log.Error(err, "Grype scan failed")
		return helper.ScanResult{}, err
	}

	err = item.Cleanup()
	if err != nil {
		log.Log.Error(err, "File could not be deleted")
	}

	if err != nil {
		log.Log.Error(fmt.Errorf("failed to catalog: %w", err), "some error")
		return helper.ScanResult{}, err
	}

	matchers := matcher.NewDefaultMatchers(matcher.Config{})
	allMatches := matcher.FindMatches(*s.store, context.Distro, matchers, packages)
	remainingMatches, _ := match.ApplyIgnoreRules(allMatches, s.config.Ignore)
	doc, err := grype_models.NewDocument(packages, context, remainingMatches, nil, s.store.MetadataProvider, nil, s.dbStatus)
	if err != nil {
		return helper.ScanResult{}, fmt.Errorf("failed to create document: %w", err)
	}
	vulns := s.buildVulnerabilities(doc, item)
	return s.filterVulnerabilities(vulns), nil
}

func (s *Grype) Close() {
	s.dbCloser.Close()
}

func loadConfig[V interface{}](configFile string, cfg V) (*V, error) {
	if configFile != "" {
		_, err := os.Stat(configFile)
		if err == nil {
			/* #nosec */
			data, err := os.ReadFile(configFile)
			if err != nil {
				log.Log.Error(err, fmt.Sprintf("Count not load config-file at %s", configFile))
				return nil, err
			}

			err = yaml.Unmarshal(data, &cfg)
			if err != nil {
				log.Log.Error(err, "Failed to unmarshal the config")
				return nil, err
			}
		}

		if err != nil {
			log.Log.Error(err, "some error")
			return nil, err
		}
	}

	return &cfg, nil
}

func validateDBLoad(loadErr error, status *db.Status) error {
	if loadErr != nil {
		return fmt.Errorf("failed to load vulnerability db: %w", loadErr)
	}
	if status == nil {
		return fmt.Errorf("unable to determine DB status")
	}
	if status.Err != nil {
		return fmt.Errorf("db could not be loaded: %w", status.Err)
	}
	return nil
}

func (s *Grype) buildVulnerabilities(doc grype_models.Document, image helper.Image) []helper.Vulnerability {
	vulnerabilities := make([]helper.Vulnerability, 0)

	for _, m := range doc.Matches {
		metadata, err := s.store.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
		if err != nil {
			continue
		}

		fixedIn := []string{}
		if m.Vulnerability.Fix.State == string(v5.FixedState) {
			fixedIn = m.Vulnerability.Fix.Versions
		}

		if m.RelatedVulnerabilities != nil {
			for _, ref := range m.RelatedVulnerabilities {
				s.relatedEntries[fmt.Sprintf("%s:%s", m.Vulnerability.Namespace, m.Vulnerability.ID)] = fmt.Sprintf("%s:%s", ref.Namespace, ref.ID)
			}
		}

		v := helper.Vulnerability{
			ID:          m.Vulnerability.ID,
			Namespace:   m.Vulnerability.Namespace,
			Severity:    metadata.Severity,
			Type:        string(m.Artifact.Type),
			Description: m.Vulnerability.Description,
			Package:     m.Artifact.Name,
			Installed:   m.Artifact.Version,
			FixedIn:     fixedIn,
			FixState:    m.Vulnerability.Fix.State,
			URLs:        metadata.URLs,
			Image:       image,
			Containers:  helper.NewContainerInfos(),
		}

		if s.kubeClient != nil {
			infos, _ := s.kubeClient.GetContainersWithImage(image.ImageId())
			v.Containers = infos
		}

		vulnerabilities = append(vulnerabilities, v)
	}

	return vulnerabilities
}

func (s *Grype) filterVulnerabilities(allVulns []helper.Vulnerability) helper.ScanResult {
	severity := make([]vulnerability.Severity, 0)
	for _, sev := range s.severity {
		severity = append(severity, vulnerability.ParseSeverity(sev))
	}

	vulns := make([]helper.Vulnerability, 0)

	for _, v := range allVulns {
		if s.hasRelated(v, allVulns) {
			continue
		}

		sev := vulnerability.ParseSeverity(v.Severity)
		if contains(severity, sev) && v.Installed != "" {
			if s.onlyFixed {
				if v.FixState == string(v5.FixedState) {
					vulns = append(vulns, v)
				}
			} else {
				vulns = append(vulns, v)
			}
		}
	}

	foundVulns, auditedVulns := s.filterEngine.FilterVulnerabilities(vulns)
	return helper.ScanResult{FoundVulnerabilities: foundVulns, AuditedVulnerabilities: auditedVulns}
}

func contains(arr []vulnerability.Severity, target vulnerability.Severity) bool {
	for _, elem := range arr {
		if elem == target {
			return true
		}
	}
	return false
}

func (s *Grype) hasRelated(v helper.Vulnerability, all []helper.Vulnerability) bool {
	for original, related := range s.relatedEntries {
		if original == fmt.Sprintf("%s:%s", v.Namespace, v.ID) {
			for _, a := range all {
				if fmt.Sprintf("%s:%s", a.Namespace, a.ID) == related {
					return true
				}
			}

			return false
		}
	}

	return false
}
