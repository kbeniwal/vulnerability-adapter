/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	v5 "github.com/anchore/grype/grype/db/v5"
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/matcher"
	"github.com/anchore/grype/grype/pkg"
	"github.com/anchore/grype/grype/store"
	"github.com/anchore/grype/grype/vulnerability"
	"github.com/anchore/stereoscope/pkg/image"
	"github.com/anchore/syft/syft/pkg/cataloger"
	"github.com/ckotzbauer/libk8soci/pkg/oci"
	libk8s "github.com/ckotzbauer/libk8soci/pkg/kubernetes"
	"gopkg.in/yaml.v3"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	metaTypes "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/retry"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	policyreport "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/api/wgpolicyk8s.io/v1alpha2"
	wgclient "sigs.k8s.io/wg-policy-prototypes/policy-report/pkg/generated/v1alpha2/clientset/versioned"

	mydomainv1alpha1 "github.com/kbeniwal/vulnerability-adapter/api/v1alpha1"
)

// ImageScanAdapterConfigReconciler reconciles a ImageScanAdapterConfig object
type ImageScanAdapterConfigReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=my.domain,resources=imagescanadapterconfigs/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the ImageScanAdapterConfig object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.13.0/pkg/reconcile
func (r *ImageScanAdapterConfigReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	l := log.FromContext(ctx)

	l.Info("Reconciling", "req", req)
	
	// Load Scan Items.
	scanItems, err := loadScanItems()
	if err != nil {
		l.Error(err, "error occurred while loading scan items")
		return ctrl.Result{}, err
	}

	// Init Scanner.
	gr, err := NewGrype("", "", "negligible", false)
	if err != nil {
		panic(err.Error())
	}
	l.Info("Grype", "xxxxx", gr)

	defer gr.Close()

	// Scan Result.
	scanResult := ScanResult{FoundVulnerabilities: []Vulnerability{}, AuditedVulnerabilities: []Vulnerability{}}

	// Scan Items.
	for _, scanItem := range scanItems {
		result, err := gr.ScanItem(scanItem)

		if err == nil {
			// handle result
			scanResult = ScanResult{
				FoundVulnerabilities:   append(scanResult.FoundVulnerabilities, result.FoundVulnerabilities...),
				AuditedVulnerabilities: append(scanResult.AuditedVulnerabilities, result.AuditedVulnerabilities...),
			}
		}
	}

	foundVulns := make(map[string][]podVulnerability)
	auditedVulns := make(map[string][]podVulnerability)
	err = ProcessVulns(scanResult, foundVulns, auditedVulns)
	if err != nil {
		log.Log.Error(err, "Target could not process vulnerabilities")
	}

	err = Finalize(foundVulns, auditedVulns)
	if err != nil {
		l.Error(err, "Target could not be finalized")
	}

	return ctrl.Result{}, nil
}

func loadScanItems() ([]Image, error) {
	client := libk8s.NewClient()
	namespaces, err := client.Client.CoreV1().Namespaces().List(context.Background(), metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	scanItems := make([]Image, 0)
	for _, namespace := range namespaces.Items {
		pods, err := client.Client.CoreV1().Pods(namespace.Name).List(context.Background(), metav1.ListOptions{})
		if err != nil {
			return nil, err
		}

		images := make(map[string]bool, 0)

		for _, p := range pods.Items {
			for _, cs := range p.Status.ContainerStatuses {
				image := Image{
					RegistryImage: oci.RegistryImage{
						ImageID: cs.ImageID,
						Image:   cs.Image,
					},
				}
				if _, ok := images[cs.Image]; !ok {
					images[cs.Image] = true
					scanItems = append(scanItems, image)
				}
			}
		}
	}
	return scanItems, nil
}

func Finalize(foundVulns, auditedVulns map[string][]podVulnerability) error {
	cfg, err := DefaultConfig()
	if err != nil {
		log.Log.Error(err, "RestConfig detection failed")
		return err
	}

	ctl, err := wgclient.NewForConfig(cfg)
	if err != nil {
		log.Log.Error(err, "Client creation failed")
		return err
	}

	for _, podVulns := range foundVulns {
		finalizePodVulns(podVulns, ctl, false)
	}

	for _, podVulns := range auditedVulns {
		finalizePodVulns(podVulns, ctl, true)
	}

	return nil
}

func finalizePodVulns(podVulns []podVulnerability, ctl *wgclient.Clientset, audited bool) {
	v := podVulns[0]

	namespacedReport := ctl.Wgpolicyk8sV1alpha2().PolicyReports(v.container.Namespace)
	report := generatePolicyReport(v.container, podVulns, audited)

	_, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		log.Log.Info(fmt.Sprintf("Create PolicyReport %s/%s", v.container.Namespace, report.Name))
		_, err = namespacedReport.Create(context.Background(), report, metav1.CreateOptions{})
		if err != nil {
			log.Log.Error(err, "PolicyReport could not be created")
		}
	} else if err != nil {
		log.Log.Error(err, "PolicyReport could not be fetched")
	} else {
		retryErr := retry.RetryOnConflict(retry.DefaultRetry, func() error {
			getObj, err := namespacedReport.Get(context.Background(), report.Name, metav1.GetOptions{})
			if errors.IsNotFound(err) {
				// This doesnt ever happen even if it is already deleted or not found
				log.Log.Info(fmt.Sprintf("PolicyReport %s not found for update", report.Name))
				return nil
			}

			if err != nil {
				return err
			}

			log.Log.Info(fmt.Sprintf("Update PolicyReport %s/%s", v.container.Namespace, report.Name))
			report.SetResourceVersion(getObj.GetResourceVersion())
			_, updateErr := namespacedReport.Update(context.Background(), report, metav1.UpdateOptions{})
			return updateErr
		})

		if retryErr != nil {
			log.Log.Error(err, "PolicyReport could not be updated")
		}
	}
}

func generatePolicyReport(container ContainerInfo, vulnerabilities []podVulnerability, audited bool) *policyreport.PolicyReport {
	suffix := ""
	if audited {
		suffix = "-audited"
	}

	report := policyreport.PolicyReport{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("vuln-%s%s", container.PodName, suffix),
			Namespace: container.Namespace,
			Labels: map[string]string{
				"kubernetes.io/created-by": "vulnerability-operator",
			},
			OwnerReferences: []metav1.OwnerReference{
				{APIVersion: "v1", Kind: "Pod", Name: container.PodName, UID: container.PodUID},
			},
		},
		Scope:   &corev1.ObjectReference{Kind: "Pod", Namespace: container.Namespace, Name: container.PodName, UID: container.PodUID},
		Results: []*policyreport.PolicyReportResult{},
	}

	t := time.Now()
	tUnix := t.Unix()
	tUnixNano := int32(t.UnixNano())

	for _, v := range vulnerabilities {
		result := policyreport.PolicyReportResult{
			Timestamp:   metav1.Timestamp{Nanos: tUnixNano, Seconds: tUnix},
			Policy:      v.vulnerability.ID,
			Description: fmt.Sprintf("%s: %s", v.vulnerability.Package, v.vulnerability.ID),
			Source:      "vulnerability-operator",
			Category:    v.vulnerability.Package,
			Scored:      false,
			Subjects: []*corev1.ObjectReference{
				{
					Kind:      "Pod",
					Namespace: container.Namespace,
					Name:      container.PodName,
					UID:       container.PodUID,
				},
			},
			Severity: mapSeverity(v.vulnerability.Severity),
			Properties: map[string]string{
				"InstalledVersion": v.vulnerability.Installed,
				"FixedVersion":     firstOrEmpty(v.vulnerability.FixedIn),
				"URL":              firstOrEmpty(v.vulnerability.URLs),
			},
			Result: mapResult(v.vulnerability.Severity),
		}

		report.Results = append(report.Results, &result)
	}

	report.Summary = toSummaryPolicy(report.Results)
	return &report
}

func mapSeverity(s string) policyreport.PolicyResultSeverity {
	if s == "Low" {
		return "low"
	} else if s == "Medium" {
		return "medium"
	} else if s == "High" || s == "Critical" {
		return "high"
	}

	return ""
}

func mapResult(s string) policyreport.PolicyResult {
	if s == "Low" {
		return "warn"
	} else if s == "Medium" || s == "High" || s == "Critical" {
		return "fail"
	}

	return "pass"
}

func toSummaryPolicy(results []*policyreport.PolicyReportResult) policyreport.PolicyReportSummary {
	var rs policyreport.PolicyReportSummary
	for _, v := range results {
		switch v.Result {
		case "error":
			rs.Error++
		case "fail":
			rs.Fail++
		case "warn":
			rs.Warn++
		case "pass":
			rs.Pass++
		default:
			rs.Skip++
		}
	}
	return rs
}

func firstOrEmpty(slice []string) string {
	if len(slice) > 0 {
		return slice[0]
	}

	return ""
}

func DefaultConfig() (*rest.Config, error) {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()

	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	return config, nil
}

func ProcessVulns(result ScanResult, foundVulns, auditedVulns map[string][]podVulnerability) error {
	for _, v := range result.FoundVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := foundVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			foundVulns[id] = podVulns
		}
	}

	for _, v := range result.AuditedVulnerabilities {
		for _, c := range v.Containers {
			id := fmt.Sprintf("%s/%s", c.Namespace, c.PodName)
			podVulns, ok := auditedVulns[id]
			if !ok {
				podVulns = []podVulnerability{}
			}

			podVulns = append(podVulns, podVulnerability{container: c, vulnerability: v})
			auditedVulns[id] = podVulns
		}
	}

	return nil
}

type podVulnerability struct {
	container     ContainerInfo
	vulnerability Vulnerability
}

func (s *Grype) ScanItem(item Image) (ScanResult, error) {
	// item, err := preprocessScan(item)
	// if err != nil {
	// 	return ScanResult{}, err
	// }

	registryOptions := &image.RegistryOptions{}
	registryOptions.Credentials = oci.ConvertSecrets(item.RegistryImage, map[string]string{})

	packages, context, _, err := pkg.Provide(item.ScanInput(), pkg.ProviderConfig{
		SyftProviderConfig: pkg.SyftProviderConfig{
			CatalogingOptions: cataloger.DefaultConfig(),
			RegistryOptions:   registryOptions,
		},
	})
	if err != nil {
		log.Log.Error(err, "Grype scan failed")
		return ScanResult{}, err
	}

	err = item.Cleanup()
	if err != nil {
		log.Log.Error(err, "File could not be deleted")
	}

	if err != nil {
		log.Log.Error(fmt.Errorf("failed to catalog: %w", err), "some error")
		return ScanResult{}, err
	}

	matchers := matcher.NewDefaultMatchers(matcher.Config{})
	allMatches := matcher.FindMatches(*s.store, context.Distro, matchers, packages)
	remainingMatches, _ := match.ApplyIgnoreRules(allMatches, s.config.Ignore)
	vulns := s.buildVulnerabilities(remainingMatches, item.ImageId())
	return s.filterVulnerabilities(vulns), nil
}

func (s *Grype) buildVulnerabilities(matches match.Matches, imageID string) []Vulnerability {
	vulnerabilities := make([]Vulnerability, 0)

	for m := range matches.Enumerate() {
		metadata, err := s.store.GetMetadata(m.Vulnerability.ID, m.Vulnerability.Namespace)
		if err != nil {
			continue
		}

		fixedIn := []string{}
		if m.Vulnerability.Fix.State == v5.FixedState {
			fixedIn = m.Vulnerability.Fix.Versions
		}

		if m.Vulnerability.RelatedVulnerabilities != nil {
			for _, ref := range m.Vulnerability.RelatedVulnerabilities {
				s.relatedEntries[fmt.Sprintf("%s:%s", m.Vulnerability.Namespace, m.Vulnerability.ID)] =
					fmt.Sprintf("%s:%s", ref.Namespace, ref.ID)
			}
		}

		v := Vulnerability{
			ID:         m.Vulnerability.ID,
			Namespace:  m.Vulnerability.Namespace,
			Severity:   metadata.Severity,
			Type:       string(m.Package.Type),
			Package:    m.Package.Name,
			Installed:  m.Package.Version,
			FixedIn:    fixedIn,
			FixState:   string(m.Vulnerability.Fix.State),
			URLs:       metadata.URLs,
			ImageID:    imageID,
			Containers: []ContainerInfo{},
		}

		if s.kubeClient != nil {
			infos, _ := s.kubeClient.GetContainersWithImage(imageID)
			v.Containers = infos
		}

		vulnerabilities = append(vulnerabilities, v)
	}

	return vulnerabilities
}

func (client *KubeClient) GetContainersWithImage(imageID string) ([]ContainerInfo, error) {
	if client.pods == nil {
		err := client.loadPods()

		if err != nil {
			return nil, err
		}
	}

	infos := make([]ContainerInfo, 0)

	for _, p := range client.pods {
		ref := p.Namespace + "/" + p.Name
		owner, ok := client.owners[ref]
		if !ok {
			owner = client.getOwner(p)
		}
		client.owners[ref] = owner

		statuses := p.Status.ContainerStatuses
		statuses = append(statuses, p.Status.InitContainerStatuses...)
		statuses = append(statuses, p.Status.EphemeralContainerStatuses...)

		for _, c := range statuses {
			fixedImageID := strings.ReplaceAll(c.ImageID, "docker-pullable://", "")
			if fixedImageID == imageID {
				infos = append(infos, ContainerInfo{
					Namespace:     p.Namespace,
					PodName:       p.Name,
					PodUID:        p.UID,
					OwnerName:     owner.name,
					OwnerKind:     owner.kind,
					ContainerName: c.Name,
				})
			}
		}
	}

	return infos, nil
}

func (client *KubeClient) getOwner(pod corev1.Pod) owner {
	ownerKind, ownerName := getOwnerKindAndName(pod.OwnerReferences)
	ctx := context.Background()

	if ownerKind == "ReplicaSet" {
		rs, _ := client.Client.Client.AppsV1().ReplicaSets(pod.Namespace).Get(ctx, ownerName, metav1.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(rs.OwnerReferences)
		return owner{kind: ownerKind, name: ownerName}
	} else if ownerKind == "Job" {
		job, _ := client.Client.Client.BatchV1().Jobs(pod.Namespace).Get(ctx, ownerName, metav1.GetOptions{})
		ownerKind, ownerName = getOwnerKindAndName(job.OwnerReferences)
		if ownerKind == "" && ownerName == "" {
			return owner{kind: "Job", name: job.Name}
		} else {
			return owner{kind: ownerKind, name: ownerName}
		}
	} else if ownerKind != "" {
		// A StatefulSet, DaemonSet or CRD-Operator created the pod
		return owner{kind: ownerKind, name: ownerName}
	} else {
		// Single pod without owner
		return owner{kind: "Pod", name: pod.Name}
	}
}

func getOwnerKindAndName(refs []metav1.OwnerReference) (string, string) {
	if len(refs) > 0 {
		return refs[0].Kind, refs[0].Name
	}

	return "", ""
}

func (client *KubeClient) loadPods() error {
	list, err := client.Client.Client.CoreV1().Pods("").List(context.Background(), metav1.ListOptions{})

	if err != nil {
		log.Log.Error(err, "ListPods errored!")
		return err
	}

	client.pods = list.Items
	return nil
}

func (s *Grype) filterVulnerabilities(allVulns []Vulnerability) ScanResult {
	minSeverity := vulnerability.ParseSeverity(s.minSeverity)

	vulns := make([]Vulnerability, 0)

	for _, v := range allVulns {
		if s.hasRelated(v, allVulns) {
			continue
		}

		sev := vulnerability.ParseSeverity(v.Severity)
		if sev >= minSeverity && v.Installed != "" {
			if s.onlyFixed {
				if v.FixState == string(v5.FixedState) {
					vulns = append(vulns, v)
				}
			} else {
				vulns = append(vulns, v)
			}
		}
	}

	foundVulns, auditedVulns := s.filterEngine.FilterVulnerabilities(vulns)
	return ScanResult{FoundVulnerabilities: foundVulns, AuditedVulnerabilities: auditedVulns}
}

func (f *FilterEngine) FilterVulnerabilities(vulns []Vulnerability) ([]Vulnerability, []Vulnerability) {
	audited := make([]Vulnerability, 0)
	found := make([]Vulnerability, 0)

	for _, vuln := range vulns {
		_, notFiltered := matchesAnyFilter(vuln, f.config.Ignore)
		filtered, notFiltered := matchesAnyFilter(notFiltered, f.config.Audit)
		if len(filtered.Containers) > 0 {
			audited = append(audited, filtered)
		}

		if len(notFiltered.Containers) > 0 {
			found = append(found, notFiltered)
		}
	}

	return found, audited
}

func matchesAnyFilter(v Vulnerability, filters []VulnerabilityFilter) (Vulnerability, Vulnerability) {
	for _, filter := range filters {
		match, filtered, notFiltered := matches(v, filter)
		if match {
			return filtered, notFiltered
		}
	}

	return Vulnerability{}, v
}

func matches(v Vulnerability, filter VulnerabilityFilter) (bool, Vulnerability, Vulnerability) {
	appliedContainers := make([]ContainerInfo, 0)
	notAppliedContainers := make([]ContainerInfo, 0)

	if len(filter.Context) > 0 {
		for _, ctx := range filter.Context {
			for _, container := range v.Containers {
				name := container.OwnerName
				if container.OwnerKind == "Pod" {
					name = container.PodName
				}

				if matchesContainer(v.ImageID, ctx.Image) &&
					matchesContainer(container.OwnerKind, ctx.Kind) &&
					matchesContainer(name, ctx.Name) &&
					matchesContainer(container.Namespace, ctx.Namespace) {
					appliedContainers = append(appliedContainers, container)
				} else {
					notAppliedContainers = append(notAppliedContainers, container)
				}
			}
		}
	} else {
		appliedContainers = v.Containers
	}

	if len(appliedContainers) == 0 {
		return false, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	if v.ID == filter.Vulnerability {
		return true, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	if v.Package == filter.Package {
		return true, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
	}

	return false, fromVulnerability(v, appliedContainers), fromVulnerability(v, notAppliedContainers)
}

func matchesContainer(value, pattern string) bool {
	if pattern == "" {
		return true
	}

	return IsMatch(value, pattern)
}

func IsMatch(s string, p string) bool {
	runeInput := []rune(s)
	runePattern := []rune(p)

	lenInput := len(runeInput)
	lenPattern := len(runePattern)

	isMatchingMatrix := make([][]bool, lenInput+1)

	for i := range isMatchingMatrix {
		isMatchingMatrix[i] = make([]bool, lenPattern+1)
	}

	isMatchingMatrix[0][0] = true
	for i := 1; i < lenInput; i++ {
		isMatchingMatrix[i][0] = false
	}

	if lenPattern > 0 {
		if runePattern[0] == '*' {
			isMatchingMatrix[0][1] = true
		}
	}

	for j := 2; j <= lenPattern; j++ {
		if runePattern[j-1] == '*' {
			isMatchingMatrix[0][j] = isMatchingMatrix[0][j-1]
		}

	}

	for i := 1; i <= lenInput; i++ {
		for j := 1; j <= lenPattern; j++ {

			if runePattern[j-1] == '*' {
				isMatchingMatrix[i][j] = isMatchingMatrix[i-1][j] || isMatchingMatrix[i][j-1]
			}

			if runePattern[j-1] == '?' || runeInput[i-1] == runePattern[j-1] {
				isMatchingMatrix[i][j] = isMatchingMatrix[i-1][j-1]
			}
		}
	}

	return isMatchingMatrix[lenInput][lenPattern]
}

func fromVulnerability(v Vulnerability, containers []ContainerInfo) Vulnerability {
	return Vulnerability{
		ID:         v.ID,
		Namespace:  v.Namespace,
		Severity:   v.Severity,
		Type:       v.Type,
		Package:    v.Package,
		Installed:  v.Installed,
		FixedIn:    v.FixedIn,
		FixState:   v.FixState,
		URLs:       v.URLs,
		ImageID:    v.ImageID,
		Containers: containers,
	}
}

func (s *Grype) hasRelated(v Vulnerability, all []Vulnerability) bool {
	for original, related := range s.relatedEntries {
		if original == fmt.Sprintf("%s:%s", v.Namespace, v.ID) {
			for _, a := range all {
				if fmt.Sprintf("%s:%s", a.Namespace, a.ID) == related {
					return true
				}
			}

			return false
		}
	}

	return false
}

func validateDBLoad(loadErr error, status *db.Status) error {
	if loadErr != nil {
		return fmt.Errorf("failed to load vulnerability db: %w", loadErr)
	}
	if status == nil {
		return fmt.Errorf("unable to determine DB status")
	}
	if status.Err != nil {
		return fmt.Errorf("db could not be loaded: %w", status.Err)
	}
	return nil
}

type Vulnerability struct {
	ID         string
	Namespace  string
	Severity   string
	Type       string
	Package    string
	Installed  string
	FixedIn    []string
	FixState   string
	URLs       []string
	ImageID    string
	Containers []ContainerInfo
}

type ContainerInfo struct {
	Namespace     string
	OwnerName     string
	OwnerKind     string
	PodName       string
	PodUID        metaTypes.UID
	ContainerName string
}

type ScanResult struct {
	FoundVulnerabilities   []Vulnerability
	AuditedVulnerabilities []Vulnerability
}

type KubeClient struct {
	Client *libk8s.KubeClient
	pods   []corev1.Pod
	owners map[string]owner
}

type owner struct {
	kind string
	name string
}

type Image struct {
	oci.RegistryImage
}

func (s Image) ImageId() string {
	return s.ImageID
}

func (s Image) ScanInput() string {
	return "registry:" + s.Image
}

func (s Image) Cleanup() error {
	return nil
}

type grypeConfig struct {
	Ignore []match.IgnoreRule `yaml:"ignore"`
}

func (s *Grype) Close() {
	s.dbCloser.Close()
}

func loadConfig[V interface{}](configFile string, cfg V) (*V, error) {
	if configFile != "" {
		_, err := os.Stat(configFile)
		if err == nil {
			/* #nosec */
			data, err := os.ReadFile(configFile)
			if err != nil {
				log.Log.Error(err, fmt.Sprintf("Count not load config-file at %s", configFile))
				return nil, err
			}

			err = yaml.Unmarshal(data, &cfg)
			if err != nil {
				log.Log.Error(err, "Failed to unmarshal the config")
				return nil, err
			}
		}

		if err != nil {
			log.Log.Error(err, "some error")
			return nil, err
		}
	}

	return &cfg, nil
}

type Grype struct {
	store          *store.Store
	dbCloser       *db.Closer
	kubeClient     *KubeClient
	config         grypeConfig
	relatedEntries map[string]string
	onlyFixed      bool
	minSeverity    string
	filterEngine   *FilterEngine
}

type FilterEngine struct {
	config *FilterConfig
}

type FilterConfig struct {
	Ignore []VulnerabilityFilter `yaml:"ignore"`
	Audit  []VulnerabilityFilter `yaml:"audit"`
}

type VulnerabilityFilter struct {
	Vulnerability string          `yaml:"vulnerability"`
	Package       string          `yaml:"package"`
	Context       []FilterContext `yaml:"context"`
}

type FilterContext struct {
	Image     string `yaml:"image"`
	Namespace string `yaml:"namespace"`
	Name      string `yaml:"name"`
	Kind      string `yaml:"kind"`
}

func NewGrype(grypeConfigFile, filterConfigFile, minSeverity string, onlyFixed bool) (Grype, error) {
	grypeCfg, err := loadConfig(grypeConfigFile, grypeConfig{})
	if err != nil {
		return Grype{}, err
	}

	config := db.Config{
		ListingURL: "https://toolbox-data.anchore.io/grype/databases/listing.json",
		DBRootDir:  "/tmp/grype/db",
	}

	log.Log.Info("Load vulnerability database")
	store, dbStatus, dbCloser, err := grype.LoadVulnerabilityDB(config, true)
	if err = validateDBLoad(err, dbStatus); err != nil {
		log.Log.Error(err, "load db error")
		return Grype{}, err
	}
	log.Log.Info("got", "store", store, "dbStatus", dbStatus, "dbCloser", dbCloser)

	filterConfig, err := loadConfig(filterConfigFile, FilterConfig{})
	if err != nil {
		return Grype{}, err
	}

	client := &KubeClient{
		Client: libk8s.NewClient(),
		owners: make(map[string]owner),
	}

	log.Log.Info("INFO", "store", store,
		"dbCloser", dbCloser,
		"kubeClient", client,
		"config", *grypeCfg,
		"minSeverity", minSeverity,
		"onlyFixed", onlyFixed,
		"relatedEntries", map[string]string{})

	return Grype{
		store:          store,
		dbCloser:       dbCloser,
		kubeClient:     client,
		config:         *grypeCfg,
		minSeverity:    minSeverity,
		onlyFixed:      onlyFixed,
		relatedEntries: map[string]string{},
		filterEngine:   &FilterEngine{config: filterConfig},
	}, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *ImageScanAdapterConfigReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&mydomainv1alpha1.ImageScanAdapterConfig{}).
		Complete(r)
}
